r <- selectLayer(input$layer, input$scen)
r <- projectRasterForLeaflet(r, method = "bilinear")
pal <- colorNumeric(palette = "Blues", domain = values(r),
na.color = "transparent")
leaflet() %>% setView(lng = -70, lat = 40, zoom = 2) %>%
addTiles %>%
addRasterImage(r, colors = pal, opacity = 0.9) %>%
addLegend("bottomleft", pal = pal, values = values(r))
})
output$plot1 <- output$plot2 <- renderPlotly({
# Variable definition (input from UI) ------------------------------------#
setLatMin(-60)
setLatMax(60)
setFb(input$FbInput * 1000)
setVb(input$VbInput * 8760)
setCRFg(input$CRFgInput)
setCRFs(input$CRFsInput)
# Run calculations from pvCompAdv package --------------------------------#
# calculate autarky results
autarkyMaps <- autarky_calc()
autarkyMaps[[4]] <- autarkyMaps[[4]] / 8760
autarkyMaps[[9]] <- autarkyMaps[[9]] / 8760
# TRADE E/W calcs
ewTradeMaps <- tradeEW_calc()
ewTradeMaps[[4]] <- ewTradeMaps[[4]] / 8760
ewTradeMaps[[9]] <- ewTradeMaps[[9]] / 8760
# TRADE N/S calcs
nsTradeMaps <- tradeNS_calc()
nsTradeMaps[[4]] <- nsTradeMaps[[4]] / 8760
nsTradeMaps[[9]] <- nsTradeMaps[[9]] / 8760
# TRADE G/G calcs
ggTradeMaps <- tradeGG_calc()
ggTradeMaps[[4]] <- ggTradeMaps[[4]] / 8760
ggTradeMaps[[9]] <- ggTradeMaps[[9]] / 8760
# Create visualization ---------------------------------------------------#
# Create data frame for visualization, stacking relevant results rasters
tradeCostsPlot <- raster::stack(autarkyMaps[[9]], ewTradeMaps[[9]],
nsTradeMaps[[9]], ggTradeMaps[[9]])
# Convert rasters to dataframe
tradeCostsData <- raster::as.data.frame(tradeCostsPlot, xy = TRUE)
# Find average values by latitude
unitCostPerLat <- tradeCostsData %>%
group_by(y) %>% summarise(costA = mean(unitCost_autarky, na.rm = TRUE),
costEW = mean(unitCost_E.W_trade, na.rm = TRUE),
costNS = mean(unitCost_N.S_trade, na.rm = TRUE),
costGG = mean(unitCost_G.G_trade, na.rm = TRUE))
# Convert dataframe from wide to long format
unitCostToPlot <- tidyr::gather(unitCostPerLat, "type", "cost", -y)
# Convert $type to a factor variable, and order as in manuscript
unitCostToPlot$type <- factor(unitCostToPlot$type,
levels = c("costA", "costEW",
"costNS", "costGG"))
# Create ggplot geom_line from data frame
fig7Alt <- ggplot(unitCostToPlot, aes(y, cost, color = type)) +
geom_line() + scale_color_gdocs(labels = c("Cost in autarky",
"Cost of E-W trade",
"Cost of N-S trade",
"Cost of global grid")) +
xlab("Latitude") + ylab("$/MW") + theme_minimal() +
theme(legend.key = element_rect(fill = NA, color = NA),
legend.title = element_blank(),
legend.position = "bottom",
axis.title.y = element_text(size = 10,
color = "black"),
axis.text = element_text(color = "black"),
axis.title.x = element_text(color = "black"),
strip.text = element_text(color = "black"))
fig7Alt <- ggplotly(fig7Alt)
})
output$plot <- renderPlotly({
# define variables
x <- seq(0, 0.999, length= 101) #  Cpv/Cb
k <- seq(0, 0.999, length= 101)
w <- input$w
# calculate excess threshold
e<- function(w = input$w){ (w+2)/(2*(w+1)) }
# Proposition 2 (beta)
p2<- function (x, k, w) { # x = Cpv/Cb
return ( x * ((w^2 + w)/(2*(k + w*k - w -1))) + ((2*k - 2*w - 2 + w*k)/(2*(k + w*k - w -1))) )
}
# leave ony values of Prop2 above e and below 1
mat<- outer(x, k, p2, w = input$w)
mat2<- ifelse(mat < e(input$w), NA, mat)
# merge prop 2 with e
newmat<- apply(mat2, 2, function(x) replace(x, which(is.na(x))[1], e(input$w)))
# Proposition 1
bound0rev<- function (w = input$w, k) {
return ((2+w-w*k)/(2*(w+1)))
}
# Prop. 1: whats the Cpv/Cb at which beta goes from 0 to 1
ratio<- bound0rev(input$w, k = seq(0, 1, length= 101))
# create matrix with x = ratio, k = k, values = e
matb<- matrix(NA, ncol = 101, nrow = 101)
diag(matb)<- e(input$w)
matb[lower.tri(matb)] <- 0
matb[upper.tri(matb)] <- e(input$w) # the seat of the chair
# calculate optimal PV coverage for the input introduced by the user
z<- ifelse(p2(x = input$x, k = input$k, w = input$w) > 1, 1,
ifelse(p2(x = input$x, k = input$k, w = input$w) < e(input$w),
ifelse(bound0rev(w = input$w, k = input$k) > input$x, e(input$w), 0.1),
p2(x = input$x, k = input$k, w = input$w)))
betaplot<- plot_ly(showscale = F, showlegend = T) %>%
add_surface(x = x, y = k, z = t(newmat), opacity = 0.8,
colorscale = list(c(0, 1), c("blue", "blue"))) %>%
add_surface(x = ratio, y = k, z = matb, opacity = 0.8,
colorscale = list(c(0, 1), c("blue", "blue"))) %>%
add_trace(x = input$x, y = input$k, z = z, mode = "markers", type = "scatter3d",
marker = list(size = 7, color = "red", symbol = 104, text = "PV coverage")) %>%
layout(scene = list(
xaxis = list(title = "Cpv/Cb"),
yaxis = list(title = "k"),
zaxis = list(title = "beta", range = c(0.1, 1))))
})
}
# Run shiny app (locally) ----------------------------------------------------#
shinyApp(ui, server)
# 2. Results calculation ------------------------------------------------------
# Autarky calcs
autarkyMaps <- autarky_calc()
# cost data for calculation of unit costs (baseload)
setFb(779000.0)
setVb(23.3*8760.0)
setCRFg(32.53)
setCRFs(19.27)
globalw <- getW(latMin, latMax)
# 2. Results calculation ------------------------------------------------------
# Autarky calcs
autarkyMaps <- autarky_calc()
library(PVcompAdv)
# package / library calls
library(ggthemes)
library(viridis)
library(lubridate)
library(hexbin)
library(raster)
library(rgdal)
library(plotly)
library(tidyverse)
library(rasterVis)
library(colorspace)
library(leaflet)
library(egg)
library(ggplot2)
library(patchwork)
library(maptools)
library(maps)
library(sp)
# set / get working directory
wkDir <- paste("/Users/keithwilliges/OneDrive/Documents/GitHub/PV-global-trade/",
sep = "")
setwd(wkDir)
getwd()
# 1. Input data definition  ---------------------------------------------------
# Defines spatial extent N and S
setLatMin(-60)
setLatMax(60)
# cost data for calculation of unit costs (baseload)
setFb(779000.0)
setVb(23.3*8760.0)
setCRFg(32.53)
setCRFs(19.27)
globalw <- getW(latMin, latMax)
# 2. Results calculation ------------------------------------------------------
# Autarky calcs
autarkyMaps <- autarky_calc()
# Testing space:
latmin <- getLatMin()
latmax <- getLatMax()
gridW <- getW(latmin, latmax)
Vb <- getVb()
Fb <- getFb()
CRFg <- getCRFg()
CRFs <- getCRFs()
cPVMap <- CpvCalc(CRFg, CRFs, latmax, latmin, getInterpolation(),
getPvMap(), isAorNS = TRUE, isEW = FALSE)
interpolation <- getInterpolation()
OCFval <- subset(interpolation, key == "OCF" & Lat <= latmax &
Lat >= latmin, select = c(Lat, value))
SGval <- subset(interpolation, key == "SG" & Lat <= latmax &
Lat >= latmin, select = c(Lat, value))
# calculate the numerator of the Cpv calc ((ocf * CRFg) + (sg*CRFs))
Cpv_temp <- dplyr::mutate(OCFval, numerator = (OCFval$value * CRFgVal) +
(SGval$value * CRFsVal))
# remove the unnecessary column from Cpv_temp
Cpv_temp <- Cpv_temp[,-2]
# convert the Cpv_temp vector into a matrix to use in calculations
Cpv_raster <- replicate(360, Cpv_temp$numerator)
# limit the worldPV raster to the correct raster::extent
e <- raster::extent(-179, 180, latmin - 0.5, latmax + 0.5)
worldPVraster_c <- raster::crop(worldPVraster, e)
worldPVraster <- getPvMap()
getwd()
# Load the worldPVOUT raster
worldPVraster <- raster::raster('./Data/WorldPVOUT/worldPV_resampledRasterFull')
# Load the worldPVOUT raster
worldPVraster <- raster::raster('./Data/WorldPVOUT/worldPV_resampledRasterFull.grd')
# Load the worldPVOUT raster
worldPVraster <- raster::raster('./Data/WorldPVOUT/worldPV_resampledRasterFull.gri')
# Load the worldPVOUT raster
worldPVraster <- raster::raster('./Data/WorldPVOUT/worldPV_resampledRasterFull.grd')
worldPVraster <- readGDAL('./Data/WorldPVOUT/worldPV_resampledRasterFull')
worldPVraster <- readOGR('./Data/WorldPVOUT/worldPV_resampledRasterFull')
worldPVraster <- readOGR('./Data/WorldPVOUT/worldPV_resampledRasterFull.grd')
worldPVraster <- readOGR('./Data/WorldPVOUT/worldPV_resampledRasterFull.gri')
worldPVraster <- readGDAL('./Data/WorldPVOUT/worldPV_resampledRasterFull.gri')
worldPVraster <- readGDAL('./Data/WorldPVOUT/worldPV_resampledRasterFull.grd')
GDALinfo('./Data/WorldPVOUT/worldPV_resampledRasterFull.grd')
GDALinfo('./Data/WorldPVOUT/worldPV_resampledRasterFull.gri')
getwd()
rgdal::GDALinfo('./Data/WorldPVOUT/worldPV_resampledRasterFull.grd')
worldPVraster <- raster::raster('./Data/WorldPVOUT/worldPV_resampledRasterFull')
cPVMap <- CpvCalc(CRFg, CRFs, latmax, latmin, getInterpolation(),
getPvMap(), isAorNS = TRUE, isEW = FALSE)
# ----------------------------------------------------------------------------#
library(shinythemes)
library(shiny)
library(plotly)
library(ggplot2)
library(ggthemes)
library(dplyr)
library(raster)
library(leaflet)
#rsconnect::setAccountInfo(name='kawilliges',
#                          token = '',
#                          secret = '')
dropdownMap <- c('Cost of PV' = 'Cpv',
'PV coverage' = 'beta',
'Winter hole' = 'w',
'Unit cost' = 'unitCost',
'Willingness to pay' = 'WTP')
dropdownScen <- c('Autarky' = 'autarky',
'East-West trade' = 'EW',
'North-South trade' = 'NS',
'Global grid' = 'GG')
ui <-  navbarPage(theme = shinytheme("simplex"),
"Comparative advantage in PV production", fluid = TRUE,
tabPanel("Interactive Map",
fluidPage(
tags$head(
tags$style(
HTML(".shiny-notification {
position:fixed;
top: calc(50%);
left: calc(50%);
}
"
)
)
),
leafletOutput("map", width = 1200, height = 700),
absolutePanel(id = 'controls', class = 'panel panel-default',
fixed = TRUE, draggable = TRUE, top = 60, left = 'auto',
right = 20, bottom = 'auto', width = 330, height = 'auto',
# sidebarPanel(h3('Input parameters'),
sliderInput("FbInput", "Annualized fixed costs (1,000 $/MW)",
min = 100, max = 1250, value = 779, step = 50),
div(id='my_div',style='margin-top:-10px;'),
sliderInput("VbInput", "Variable costs (unit terms) ($/MWh)",
min = 10, max = 50, value = 23.3, step = 1),
div(id='my_div',style='margin-top:-10px;'),
sliderInput("CRFgInput", "Capital recovery factor (PV)",
min = 20, max = 60, value = 32, step = 1),
div(id='my_div',style='margin-top:-10px;'),
sliderInput("CRFsInput", "Capital recovery factor (storage)",
min = 10, max = 50, value = 19, step = 1),
div(id='my_div',style='margin-top:-10px;'),
selectInput("layer", "Map of:", dropdownMap),
div(id='my_div',style='margin-top:-10px;'),
selectInput("scen", "Scenario:", dropdownScen),
plotlyOutput("plot1", height = 170)
)
)
),
tabPanel("Interactive Chart",
fluidRow(column = 12,
fluidRow(
column(4,
sliderInput("FbInput", "Annualized fixed costs (1,000 $/MW)",
min = 100, max = 1250, value = 547, step = 50),
sliderInput("VbInput", "Variable costs (unit terms) ($/MWh)",
min = 10, max = 50, value = 23.3, step = 1),
sliderInput("CRFgInput", "Capital recovery factor (PV)",
min = 20, max = 60, value = 32, step = 1),
sliderInput("CRFsInput", "Capital recovery factor (storage)",
min = 10, max = 50, value = 19, step = 1)
),
column(8, plotlyOutput("plot2"))
)
)
),
tabPanel("Theoretical eval.",
fluidRow(column = 12,
fluidRow(
column(4,
sliderInput("w", "Winter hole (w)", min = 0, max = 10, value = 1, step = .5),
sliderInput("k", "Share of fixed baseload cost (k)", min = 0, max = 1, value = .7),
sliderInput("x", "PV/baseload unit cost ratio (Cpv/Cb)", min = 0, max = 1, value = .5)
),
column(8, plotlyOutput("plot"))
)
)
)
)
server <- function(input, output){
output$map <- renderLeaflet({
# Variable definition (input from UI) ------------------------------------#
setLatMin(-60)
setLatMax(60)
setFb(input$FbInput * 1000)
setVb(input$VbInput * 8760)
setCRFg(input$CRFgInput)
setCRFs(input$CRFsInput)
# Run calculations from pvCompAdv package --------------------------------#
# calculate autarky results
autarkyMaps <- autarky_calc()
autarkyMaps[[4]][autarkyMaps[[4]] > (200*8760)] <- NA
autarkyMaps[[4]] <- autarkyMaps[[4]] / 8760
autarkyMaps[[9]] <- autarkyMaps[[9]] / 8760
# TRADE E/W calcs
ewTradeMaps <- tradeEW_calc()
ewTradeMaps[[4]] <- ewTradeMaps[[4]] / 8760
ewTradeMaps[[9]] <- ewTradeMaps[[9]] / 8760
wtpEWMap <- (autarkyMaps[[9]] - ewTradeMaps[[9]])
ewTradeMaps <- stack(ewTradeMaps, wtpEWMap)
# TRADE N/S calcs
nsTradeMaps <- tradeNS_calc()
nsTradeMaps[[4]] <- nsTradeMaps[[4]] / 8760
nsTradeMaps[[9]] <- nsTradeMaps[[9]] / 8760
wtpNSMap <- (autarkyMaps[[9]] - nsTradeMaps[[9]])
nsTradeMaps <- stack(nsTradeMaps, wtpNSMap)
# TRADE G/G calcs
ggTradeMaps <- tradeGG_calc()
ggTradeMaps[[4]] <- ggTradeMaps[[4]] / 8760
ggTradeMaps[[9]] <- ggTradeMaps[[9]] / 8760
wtpGGMap <- (autarkyMaps[[9]] - ggTradeMaps[[9]])
ggTradeMaps <- stack(ggTradeMaps, wtpGGMap)
selectLayer <- function(inputLayer, inputScenario){
# Function to just get the raster we want to plot
# Need to print an error if the user plots willingness to pay in Autarky
layerNr <- ifelse(inputLayer == 'Cpv', 4,
ifelse(inputLayer == 'beta', 8,
ifelse(inputLayer == 'w', 1,
ifelse(inputLayer == 'unitCost', 9, 10))))
ifelse(inputScenario == 'autarky', ifelse(layerNr == 10,
return(showError()),
return(autarkyMaps[[layerNr]])),
ifelse(inputScenario == 'EW', return(ewTradeMaps[[layerNr]]),
ifelse(inputScenario == 'NS', return(nsTradeMaps[[layerNr]]),
return(ggTradeMaps[[layerNr]]))))
}
showError <- function(){
errorMsg <- "WTP is not calculated in an autarky case; please choose another map layer"
showNotification(ui = errorMsg, action = NULL, duration = NULL, closeButton = TRUE,
id = NULL, type = "warning",
session = getDefaultReactiveDomain())
return(autarkyMaps[[9]])
}
# Create leaflet map -----------------------------------------------------#
r <- selectLayer(input$layer, input$scen)
r <- projectRasterForLeaflet(r, method = "bilinear")
pal <- colorNumeric(palette = "Blues", domain = values(r),
na.color = "transparent")
leaflet() %>% setView(lng = -70, lat = 40, zoom = 2) %>%
addTiles %>%
addRasterImage(r, colors = pal, opacity = 0.9) %>%
addLegend("bottomleft", pal = pal, values = values(r))
})
output$plot1 <- output$plot2 <- renderPlotly({
# Variable definition (input from UI) ------------------------------------#
setLatMin(-60)
setLatMax(60)
setFb(input$FbInput * 1000)
setVb(input$VbInput * 8760)
setCRFg(input$CRFgInput)
setCRFs(input$CRFsInput)
# Run calculations from pvCompAdv package --------------------------------#
# calculate autarky results
autarkyMaps <- autarky_calc()
autarkyMaps[[4]] <- autarkyMaps[[4]] / 8760
autarkyMaps[[9]] <- autarkyMaps[[9]] / 8760
# TRADE E/W calcs
ewTradeMaps <- tradeEW_calc()
ewTradeMaps[[4]] <- ewTradeMaps[[4]] / 8760
ewTradeMaps[[9]] <- ewTradeMaps[[9]] / 8760
# TRADE N/S calcs
nsTradeMaps <- tradeNS_calc()
nsTradeMaps[[4]] <- nsTradeMaps[[4]] / 8760
nsTradeMaps[[9]] <- nsTradeMaps[[9]] / 8760
# TRADE G/G calcs
ggTradeMaps <- tradeGG_calc()
ggTradeMaps[[4]] <- ggTradeMaps[[4]] / 8760
ggTradeMaps[[9]] <- ggTradeMaps[[9]] / 8760
# Create visualization ---------------------------------------------------#
# Create data frame for visualization, stacking relevant results rasters
tradeCostsPlot <- raster::stack(autarkyMaps[[9]], ewTradeMaps[[9]],
nsTradeMaps[[9]], ggTradeMaps[[9]])
# Convert rasters to dataframe
tradeCostsData <- raster::as.data.frame(tradeCostsPlot, xy = TRUE)
# Find average values by latitude
unitCostPerLat <- tradeCostsData %>%
group_by(y) %>% summarise(costA = mean(unitCost_autarky, na.rm = TRUE),
costEW = mean(unitCost_E.W_trade, na.rm = TRUE),
costNS = mean(unitCost_N.S_trade, na.rm = TRUE),
costGG = mean(unitCost_G.G_trade, na.rm = TRUE))
# Convert dataframe from wide to long format
unitCostToPlot <- tidyr::gather(unitCostPerLat, "type", "cost", -y)
# Convert $type to a factor variable, and order as in manuscript
unitCostToPlot$type <- factor(unitCostToPlot$type,
levels = c("costA", "costEW",
"costNS", "costGG"))
# Create ggplot geom_line from data frame
fig7Alt <- ggplot(unitCostToPlot, aes(y, cost, color = type)) +
geom_line() + scale_color_gdocs(labels = c("Cost in autarky",
"Cost of E-W trade",
"Cost of N-S trade",
"Cost of global grid")) +
xlab("Latitude") + ylab("$/MW") + theme_minimal() +
theme(legend.key = element_rect(fill = NA, color = NA),
legend.title = element_blank(),
legend.position = "bottom",
axis.title.y = element_text(size = 10,
color = "black"),
axis.text = element_text(color = "black"),
axis.title.x = element_text(color = "black"),
strip.text = element_text(color = "black"))
fig7Alt <- ggplotly(fig7Alt)
})
output$plot <- renderPlotly({
# define variables
x <- seq(0, 0.999, length= 101) #  Cpv/Cb
k <- seq(0, 0.999, length= 101)
w <- input$w
# calculate excess threshold
e<- function(w = input$w){ (w+2)/(2*(w+1)) }
# Proposition 2 (beta)
p2<- function (x, k, w) { # x = Cpv/Cb
return ( x * ((w^2 + w)/(2*(k + w*k - w -1))) + ((2*k - 2*w - 2 + w*k)/(2*(k + w*k - w -1))) )
}
# leave ony values of Prop2 above e and below 1
mat<- outer(x, k, p2, w = input$w)
mat2<- ifelse(mat < e(input$w), NA, mat)
# merge prop 2 with e
newmat<- apply(mat2, 2, function(x) replace(x, which(is.na(x))[1], e(input$w)))
# Proposition 1
bound0rev<- function (w = input$w, k) {
return ((2+w-w*k)/(2*(w+1)))
}
# Prop. 1: whats the Cpv/Cb at which beta goes from 0 to 1
ratio<- bound0rev(input$w, k = seq(0, 1, length= 101))
# create matrix with x = ratio, k = k, values = e
matb<- matrix(NA, ncol = 101, nrow = 101)
diag(matb)<- e(input$w)
matb[lower.tri(matb)] <- 0
matb[upper.tri(matb)] <- e(input$w) # the seat of the chair
# calculate optimal PV coverage for the input introduced by the user
z<- ifelse(p2(x = input$x, k = input$k, w = input$w) > 1, 1,
ifelse(p2(x = input$x, k = input$k, w = input$w) < e(input$w),
ifelse(bound0rev(w = input$w, k = input$k) > input$x, e(input$w), 0.1),
p2(x = input$x, k = input$k, w = input$w)))
betaplot<- plot_ly(showscale = F, showlegend = T) %>%
add_surface(x = x, y = k, z = t(newmat), opacity = 0.8,
colorscale = list(c(0, 1), c("blue", "blue"))) %>%
add_surface(x = ratio, y = k, z = matb, opacity = 0.8,
colorscale = list(c(0, 1), c("blue", "blue"))) %>%
add_trace(x = input$x, y = input$k, z = z, mode = "markers", type = "scatter3d",
marker = list(size = 7, color = "red", symbol = 104, text = "PV coverage")) %>%
layout(scene = list(
xaxis = list(title = "Cpv/Cb"),
yaxis = list(title = "k"),
zaxis = list(title = "beta", range = c(0.1, 1))))
})
}
# Run shiny app (locally) ----------------------------------------------------#
shinyApp(ui, server)
install.packages('rsconnect')
rsconnect::setAccountInfo(name="kawilliges", token="3A790F7B47780C220828925470BC7F42", secret="zhfrLSAM+CvPWnHlhkwcA6/Ve5Ms5OdCQ2yU6IjU")
devtools::install('./PVcompAdv_0.1.0.tar')
library(devtools)
devtools::install('./PVcompAdv_0.1.0.tar')
devtools::install('./PVcompAdv_0.1.0.tar')
devtools::install('C:\Users\Keith W\OneDrive\Documents\GitHub\PV-global-trade\PVcompAdv_0.1.0.tar')
devtools::install('C:/Users/Keith W/OneDrive/Documents/GitHub/PV-global-trade/PVcompAdv_0.1.0.tar')
devtools::install('C:/Users/Keith W/OneDrive/Documents/GitHub/PV-global-trade/PVcompAdv_0.1.0.tar')
devtools::install('Users/Keith W/OneDrive/Documents/GitHub/PV-global-trade/PVcompAdv_0.1.0.tar')
devtools::install('Users/Keith W/OneDrive/Documents/GitHub/PV-global-trade/PVcompAdv_0.1.0.tar')
devtools::install('C:/Users/Keith W/OneDrive/Documents/GitHub/PV-global-trade/PVcompAdv_0.1.0.tar')
devtools::install_github('kawilliges/PvCompAdv', auth_token = "677e78d21f08e74154f716462044c7c041de7ec0")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "677e78d21f08e74154f716462044c7c041de7ec0 ")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "677e78d21f08e74154f716462044c7c041de7ec0")
devtools::install_github('kawilliges/PvCompAdv/PVcompAdv_0.1.0.tar.gz', auth_token = "677e78d21f08e74154f716462044c7c041de7ec0")
install.packages('devtools')
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
devtools::install_github('', auth_token = "677e78d21f08e74154f716462044c7c041de7ec0")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "677e78d21f08e74154f716462044c7c041de7ec0")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
library(devtools)
library(devtools)
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
install.packages('devtools')
devtools::install_github('kawilliges/PvCompAdv', auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac")
library(shiny); runApp('~/GitHub/PV-global-trade/pvMapVis-shiny.R')
install.packages('glue')
library(PVcompAdv)
library(PVcompAdv)
library(shiny); runApp('~/GitHub/PV-global-trade/pvMapVis-shiny.R')
