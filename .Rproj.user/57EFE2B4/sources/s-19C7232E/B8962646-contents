# ----------------------------------------------------------------------------#
# File: pvMapVis-shiny.R                                                   ----
#                                                                           ---
# Author: Keith Williges                                                    ---
# Description: Script for visualizing results of electricity trade model    ---
#   using Shiny web app and leaflet maps                                    ---
# Other files: Steps for calculating representative year / size of winter   ---
#   hole etc. can be found in solarDataPrep.r. Python scripts               ---
#   "dataPrepScript.py" and "dataCombineScript.py" were used on the raw data---
#   from NASA. compAdvPV.R contains package functions, baselineResults.R    ---
#   contains analysis for paper visualizations etc.                         ---
# ----------------------------------------------------------------------------#
library(shinythemes)
library(shiny)
library(plotly)
library(ggplot2)
library(ggthemes)
library(dplyr)
library(raster)
library(leaflet)
library(devtools)
library(PVcompAdv)

devtools::install_github('kawilliges/PvCompAdv',
                         auth_token = "9ab3ddfae43708fba5e4963d3314e2813f84f6ac",
                         dep = FALSE)


rsconnect::setAccountInfo(name='kawilliges',
                          token='3A790F7B47780C220828925470BC7F42',
                          secret='zhfrLSAM+CvPWnHlhkwcA6/Ve5Ms5OdCQ2yU6IjU')

dropdownMap <- c('Cost of PV' = 'Cpv',
                 'PV coverage' = 'beta',
                 'Winter hole' = 'w',
                 'Unit cost' = 'unitCost',
                 'Willingness to pay' = 'WTP')

dropdownScen <- c('Autarky' = 'autarky',
                  'East-West trade' = 'EW',
                  'North-South trade' = 'NS',
                  'Global grid' = 'GG')

ui <-  navbarPage(theme = shinytheme("simplex"),
        "Comparative advantage in PV production", fluid = TRUE,
        tabPanel("Interactive Map",
         fluidPage(
           tags$head(
             tags$style(
               HTML(".shiny-notification {
             position:fixed;
             top: calc(50%);
             left: calc(50%);
             }
             "
               )
             )
           ),
           leafletOutput("map", width = 1200, height = 700),

           absolutePanel(id = 'controls', class = 'panel panel-default',
               fixed = TRUE, draggable = TRUE, top = 60, left = 'auto',
               right = 20, bottom = 'auto', width = 330, height = 'auto',
               # sidebarPanel(h3('Input parameters'),
               sliderInput("FbInput", "Annualized fixed costs (1,000 $/MW)",
                           min = 100, max = 1250, value = 779, step = 50),
               div(id='my_div',style='margin-top:-10px;'),
               sliderInput("VbInput", "Variable costs (unit terms) ($/MWh)",
                           min = 10, max = 50, value = 23.3, step = 1),
               div(id='my_div',style='margin-top:-10px;'),
               sliderInput("CRFgInput", "Capital recovery factor (PV)",
                           min = 20, max = 60, value = 32, step = 1),
               div(id='my_div',style='margin-top:-10px;'),
               sliderInput("CRFsInput", "Capital recovery factor (storage)",
                           min = 10, max = 50, value = 19, step = 1),
               div(id='my_div',style='margin-top:-10px;'),
               selectInput("layer", "Map of:", dropdownMap),
               div(id='my_div',style='margin-top:-10px;'),
               selectInput("scen", "Scenario:", dropdownScen),

               plotlyOutput("plot1", height = 170)
           )
         )
        ),
        tabPanel("Interactive Chart",
         fluidRow(column = 12,
            fluidRow(
              column(4,
                     sliderInput("FbInput", "Annualized fixed costs (1,000 $/MW)",
                                 min = 100, max = 1250, value = 547, step = 50),
                     sliderInput("VbInput", "Variable costs (unit terms) ($/MWh)",
                                 min = 10, max = 50, value = 23.3, step = 1),
                     sliderInput("CRFgInput", "Capital recovery factor (PV)",
                                 min = 20, max = 60, value = 32, step = 1),
                     sliderInput("CRFsInput", "Capital recovery factor (storage)",
                                 min = 10, max = 50, value = 19, step = 1)
              ),
              column(8, plotlyOutput("plot2"))
            )
         )
        ),
        tabPanel("Theoretical eval.",
                 fluidRow(column = 12,
                          fluidRow(
                            column(4,
                                   sliderInput("w", "Winter hole (w)", min = 0, max = 10, value = 1, step = .5),
                                   sliderInput("k", "Share of fixed baseload cost (k)", min = 0, max = 1, value = .7),
                                   sliderInput("x", "PV/baseload unit cost ratio (Cpv/Cb)", min = 0, max = 1, value = .5)
                            ),
                            column(8, plotlyOutput("plot"))
                          )
                          )
                 )
)

server <- function(input, output){
  output$map <- renderLeaflet({
    # Variable definition (input from UI) ------------------------------------#
    setLatMin(-60)
    setLatMax(60)
    setFb(input$FbInput * 1000)
    setVb(input$VbInput * 8760)
    setCRFg(input$CRFgInput)
    setCRFs(input$CRFsInput)

    # Run calculations from pvCompAdv package --------------------------------#
    # calculate autarky results
    autarkyMaps <- autarky_calc()
    autarkyMaps[[4]][autarkyMaps[[4]] > (200*8760)] <- NA
    autarkyMaps[[4]] <- autarkyMaps[[4]] / 8760
    autarkyMaps[[9]] <- autarkyMaps[[9]] / 8760
    # TRADE E/W calcs
    ewTradeMaps <- tradeEW_calc()
    ewTradeMaps[[4]] <- ewTradeMaps[[4]] / 8760
    ewTradeMaps[[9]] <- ewTradeMaps[[9]] / 8760
    wtpEWMap <- (autarkyMaps[[9]] - ewTradeMaps[[9]])
    ewTradeMaps <- stack(ewTradeMaps, wtpEWMap)
    # TRADE N/S calcs
    nsTradeMaps <- tradeNS_calc()
    nsTradeMaps[[4]] <- nsTradeMaps[[4]] / 8760
    nsTradeMaps[[9]] <- nsTradeMaps[[9]] / 8760
    wtpNSMap <- (autarkyMaps[[9]] - nsTradeMaps[[9]])
    nsTradeMaps <- stack(nsTradeMaps, wtpNSMap)
    # TRADE G/G calcs
    ggTradeMaps <- tradeGG_calc()
    ggTradeMaps[[4]] <- ggTradeMaps[[4]] / 8760
    ggTradeMaps[[9]] <- ggTradeMaps[[9]] / 8760
    wtpGGMap <- (autarkyMaps[[9]] - ggTradeMaps[[9]])
    ggTradeMaps <- stack(ggTradeMaps, wtpGGMap)

    selectLayer <- function(inputLayer, inputScenario){
      # Function to just get the raster we want to plot

      # Need to print an error if the user plots willingness to pay in Autarky
      layerNr <- ifelse(inputLayer == 'Cpv', 4,
                        ifelse(inputLayer == 'beta', 8,
                               ifelse(inputLayer == 'w', 1,
                                      ifelse(inputLayer == 'unitCost', 9, 10))))

      ifelse(inputScenario == 'autarky', ifelse(layerNr == 10,
                                                return(showError()),
                                                return(autarkyMaps[[layerNr]])),
             ifelse(inputScenario == 'EW', return(ewTradeMaps[[layerNr]]),
                    ifelse(inputScenario == 'NS', return(nsTradeMaps[[layerNr]]),
                           return(ggTradeMaps[[layerNr]]))))
    }

    showError <- function(){
      errorMsg <- "WTP is not calculated in an autarky case; please choose another map layer"
      showNotification(ui = errorMsg, action = NULL, duration = NULL, closeButton = TRUE,
                       id = NULL, type = "warning",
                       session = getDefaultReactiveDomain())
      return(autarkyMaps[[9]])
    }

    # Create leaflet map -----------------------------------------------------#
    r <- selectLayer(input$layer, input$scen)
    r <- projectRasterForLeaflet(r, method = "bilinear")
    pal <- colorNumeric(palette = "Blues", domain = values(r),
                        na.color = "transparent")

    leaflet() %>% setView(lng = -70, lat = 40, zoom = 2) %>%
      addTiles %>%
      addRasterImage(r, colors = pal, opacity = 0.9) %>%
      addLegend("bottomleft", pal = pal, values = values(r))
  })

  output$plot1 <- output$plot2 <- renderPlotly({
    # Variable definition (input from UI) ------------------------------------#
    setLatMin(-60)
    setLatMax(60)
    setFb(input$FbInput * 1000)
    setVb(input$VbInput * 8760)
    setCRFg(input$CRFgInput)
    setCRFs(input$CRFsInput)

    # Run calculations from pvCompAdv package --------------------------------#
    # calculate autarky results
    autarkyMaps <- autarky_calc()
    autarkyMaps[[4]] <- autarkyMaps[[4]] / 8760
    autarkyMaps[[9]] <- autarkyMaps[[9]] / 8760
    # TRADE E/W calcs
    ewTradeMaps <- tradeEW_calc()
    ewTradeMaps[[4]] <- ewTradeMaps[[4]] / 8760
    ewTradeMaps[[9]] <- ewTradeMaps[[9]] / 8760
    # TRADE N/S calcs
    nsTradeMaps <- tradeNS_calc()
    nsTradeMaps[[4]] <- nsTradeMaps[[4]] / 8760
    nsTradeMaps[[9]] <- nsTradeMaps[[9]] / 8760
    # TRADE G/G calcs
    ggTradeMaps <- tradeGG_calc()
    ggTradeMaps[[4]] <- ggTradeMaps[[4]] / 8760
    ggTradeMaps[[9]] <- ggTradeMaps[[9]] / 8760

    # Create visualization ---------------------------------------------------#
    # Create data frame for visualization, stacking relevant results rasters
    tradeCostsPlot <- raster::stack(autarkyMaps[[9]], ewTradeMaps[[9]],
                                    nsTradeMaps[[9]], ggTradeMaps[[9]])

    # Convert rasters to dataframe
    tradeCostsData <- raster::as.data.frame(tradeCostsPlot, xy = TRUE)

    # Find average values by latitude
    unitCostPerLat <- tradeCostsData %>%
      group_by(y) %>% summarise(costA = mean(unitCost_autarky, na.rm = TRUE),
                                costEW = mean(unitCost_E.W_trade, na.rm = TRUE),
                                costNS = mean(unitCost_N.S_trade, na.rm = TRUE),
                                costGG = mean(unitCost_G.G_trade, na.rm = TRUE))

    # Convert dataframe from wide to long format
    unitCostToPlot <- tidyr::gather(unitCostPerLat, "type", "cost", -y)

    # Convert $type to a factor variable, and order as in manuscript
    unitCostToPlot$type <- factor(unitCostToPlot$type,
                                  levels = c("costA", "costEW",
                                             "costNS", "costGG"))
    # Create ggplot geom_line from data frame
    fig7Alt <- ggplot(unitCostToPlot, aes(y, cost, color = type)) +
      geom_line() + scale_color_gdocs(labels = c("Cost in autarky",
                                                 "Cost of E-W trade",
                                                 "Cost of N-S trade",
                                                 "Cost of global grid")) +
      xlab("Latitude") + ylab("$/MW") + theme_minimal() +
      theme(legend.key = element_rect(fill = NA, color = NA),
            legend.title = element_blank(),
            legend.position = "bottom",
            axis.title.y = element_text(size = 10,
                                        color = "black"),
            axis.text = element_text(color = "black"),
            axis.title.x = element_text(color = "black"),
            strip.text = element_text(color = "black"))

    fig7Alt <- ggplotly(fig7Alt)
  })

  output$plot <- renderPlotly({

    # define variables
    x <- seq(0, 0.999, length= 101) #  Cpv/Cb
    k <- seq(0, 0.999, length= 101)
    w <- input$w

    # calculate excess threshold
    e<- function(w = input$w){ (w+2)/(2*(w+1)) }

    # Proposition 2 (beta)
    p2<- function (x, k, w) { # x = Cpv/Cb
      return ( x * ((w^2 + w)/(2*(k + w*k - w -1))) + ((2*k - 2*w - 2 + w*k)/(2*(k + w*k - w -1))) )
    }

    # leave ony values of Prop2 above e and below 1
    mat<- outer(x, k, p2, w = input$w)
    mat2<- ifelse(mat < e(input$w), NA, mat)

    # merge prop 2 with e
    newmat<- apply(mat2, 2, function(x) replace(x, which(is.na(x))[1], e(input$w)))

    # Proposition 1
    bound0rev<- function (w = input$w, k) {
      return ((2+w-w*k)/(2*(w+1)))
    }

    # Prop. 1: whats the Cpv/Cb at which beta goes from 0 to 1
    ratio<- bound0rev(input$w, k = seq(0, 1, length= 101))

    # create matrix with x = ratio, k = k, values = e
    matb<- matrix(NA, ncol = 101, nrow = 101)
    diag(matb)<- e(input$w)
    matb[lower.tri(matb)] <- 0
    matb[upper.tri(matb)] <- e(input$w) # the seat of the chair

    # calculate optimal PV coverage for the input introduced by the user
    z<- ifelse(p2(x = input$x, k = input$k, w = input$w) > 1, 1,
               ifelse(p2(x = input$x, k = input$k, w = input$w) < e(input$w),
                      ifelse(bound0rev(w = input$w, k = input$k) > input$x, e(input$w), 0.1),
                      p2(x = input$x, k = input$k, w = input$w)))


    betaplot<- plot_ly(showscale = F, showlegend = T) %>%
      add_surface(x = x, y = k, z = t(newmat), opacity = 0.8,
                  colorscale = list(c(0, 1), c("blue", "blue"))) %>%
      add_surface(x = ratio, y = k, z = matb, opacity = 0.8,
                  colorscale = list(c(0, 1), c("blue", "blue"))) %>%
      add_trace(x = input$x, y = input$k, z = z, mode = "markers", type = "scatter3d",
                marker = list(size = 7, color = "red", symbol = 104, text = "PV coverage")) %>%
      layout(scene = list(
        xaxis = list(title = "Cpv/Cb"),
        yaxis = list(title = "k"),
        zaxis = list(title = "beta", range = c(0.1, 1))))
  })
}

# Run shiny app (locally) ----------------------------------------------------#
shinyApp(ui, server)
